/*
 *    Class implementation of the SoC Designer component <IDCT>
 *
 *    This code has been generated by the SoC Designer Component Wizard.
 *    Copyright (c) 2004-2005 by ARM Limited, 2000-2004 by AXYS Design Automation Inc., Irvine, CA, USA and AXYS GmbH, Herzongenrath
 *
 */

#include "IDCT.h"

#include <stdio.h>


#include "ahb_s_TS.h"

#include "IDCT_MxDI.h"


IDCT::IDCT(sc_mx_m_base* c, const string &s) : sc_mx_module(c, s)
{
    initComplete = false;

    ahb_s_TSlave = new ahb_s_TS( this );
    registerPort( ahb_s_TSlave, "ahb_s" );

    // Clocking the components
    SC_MX_CLOCKED();
    // Register ourself as a clock slave port.
    registerPort( dynamic_cast< sc_mx_clock_slave_p_base* >( this ), "clk-in");


    mxdi = NULL; 

    // Place parameter definitions here:
    defineParameter( "Enable Debug Messages", "false", MX_PARAM_BOOL);
    defineParameter( "ahb_s_addrSize", "0x100000000", MX_PARAM_VALUE, 0);
    defineParameter( "ahb_s_baseAddress", "0x0", MX_PARAM_VALUE, 0);

}

IDCT::~IDCT()
{

    delete ahb_s_TSlave;

}

void
IDCT::communicate()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing communicate function");
	}
#endif

	// TODO:  Add your communicate code here.
	// ...
}

void
IDCT::update()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing update function");
	}
#endif

	 // TODO:  Add your update code here.
	 // ...
}

void 
IDCT::init()
{

   // Create MXDI Interface
    mxdi = new IDCT_MxDI(this);
    r_reg0 = 0;
    r_reg1 = 0;
    r_reg2 = 0;
    r_reg3 = 0;
    r_reg4 = 0;
    r_reg5 = 0;
    r_reg6 = 0;
    r_reg7 = 0;
    r_r_status = 0;
    r_r_ctrl = 0;

	
    // Initialize ourself for save/restore.
    initStream( this );


    // Allocate memory and initialize data here:
    // ...
  
    // Call the base class after this has been initialized.
    sc_mx_module::init();

    // Set a flag that init stage has been completed
    initComplete = true;
}

void
IDCT::reset(MxResetLevel level, const MxFileMapIF *filelist)
{
    // Add your reset behavior here:
    // ...



    // Call the base class after this has been reset.
    sc_mx_module::reset(level, filelist);
}

void 
IDCT::terminate()
{
    // Call the base class first.
    sc_mx_module::terminate();

    // Release the MXDI Interface
    if(mxdi!=NULL) {delete mxdi; mxdi=NULL;}

    // Free memory which has been allocated in init stage
    // ...
}

void
IDCT::setParameter( const string &name, const string &value )
{
    MxConvertErrorCodes status = MxConvert_SUCCESS;

    if (name == "Enable Debug Messages")
    {
        status = MxConvertStringToValue( value, &p_enableDbgMsg  );
    }
    else if (name == "ahb_s_addrSize")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_s_addrSize );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }
    else if (name == "ahb_s_baseAddress")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_s_baseAddress );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }

    if ( status == MxConvert_SUCCESS )
    {
        sc_mx_module::setParameter(name, value);
    }
    else
    {
        message( MX_MSG_WARNING, "IDCT::setParameter: Illegal value <%s> "
		 "passed for parameter <%s>. Assignment ignored.", value.c_str(), name.c_str() );
    }
}

string
IDCT::getProperty( MxPropertyType property )
{
    string description; 
    switch ( property ) 
    {    
	 case MX_PROP_LOADFILE_EXTENSION:
		return "";
	 case MX_PROP_REPORT_FILE_EXT:
		return "yes";
	 case MX_PROP_COMPONENT_TYPE:
		return "Other"; 
	 case MX_PROP_COMPONENT_VERSION:
		return "0.1";
	 case MX_PROP_MSG_PREPEND_NAME:
		return "yes"; 
	 case MX_PROP_DESCRIPTION:
		description = "";
		return description + " Compiled on " + __DATE__ + ", " + __TIME__; 
	 case MX_PROP_MXDI_SUPPORT:
		return "yes";
	 case MX_PROP_SAVE_RESTORE:
		return "yes";
	 default:
		return "";
    }
}

string
IDCT::getName(void)
{
    return "IDCT";
}

MXDI*
IDCT::getMxDI()
{
    return mxdi;
}


bool
IDCT::saveData( MxODataStream &data )
{
    data << r_reg0;
    data << r_reg1;
    data << r_reg2;
    data << r_reg3;
    data << r_reg4;
    data << r_reg5;
    data << r_reg6;
    data << r_reg7;
    data << r_r_status;
    data << r_r_ctrl;


    // TODO: Add your save code here.
    // Below line shows how the example state variable is saved. 
    // data << exampleStateVariable;


    // return save was successful
	return true;
}

bool
IDCT::restoreData( MxIDataStream &data )
{
    data >> r_reg0;
    data >> r_reg1;
    data >> r_reg2;
    data >> r_reg3;
    data >> r_reg4;
    data >> r_reg5;
    data >> r_reg6;
    data >> r_reg7;
    data >> r_r_status;
    data >> r_r_ctrl;


    // TODO: Add your restore code here.
    // Below line shows how the example state variable is saved. 
    // data >> exampleStateVariable;


    // return restore was successful
	return true;
}

void
IDCT::initSignalPort(sc_mx_signal_p_base* signalIf)
{
    MxSignalProperties prop_sm1;
    memset(&prop_sm1,0,sizeof(prop_sm1));
    prop_sm1.isOptional=false;
    prop_sm1.bitwidth=32;
    signalIf->setProperties(&prop_sm1);
}

// This initTransactionPort() is only called for Transaction Master Ports.
// Do not call this function for any port which has its own initialization code.
void
IDCT::initTransactionPort(sc_mx_transaction_p_base* transIf)
{
    MxTransactionProperties prop;
    memset(&prop,0,sizeof(prop));
    prop.mxsiVersion = MXSI_VERSION_6;     //the transaction version used for this transaction
    prop.useMultiCycleInterface = false;    // using read/write interface methods
    prop.addressBitwidth = 32;      // address bitwidth used for addressing of resources 
    prop.mauBitwidth = 8;           // minimal addressable unit 
    prop.dataBitwidth = 32;         // maximum data bitwidth transferred in a single cycle 
    prop.isLittleEndian = true;     // alignment of MAUs 
    prop.isOptional = false;				// if true this port can be disabled 
    prop.supportsAddressRegions = true;	// M/S can negotiate address mapping
    prop.numCtrlFields = 1;         // # of ctrl elements used / entry is used for transfer size
    prop.protocolID = 0x00000001;           // magic number of the protocol (Vendor/Protocol-ID): 
				                             //The upper 16 bits = protocol implementation version
											//The lower 16 bits = actual protocol ID
    sprintf(prop.protocolName,"Mx");         // The name of the  protocol being used
    // MxSI 6.0: slave port address regions forwarding 
    prop.isAddrRegionForwarded = false; //true if addr region for this slave port is actually 
											//forwarded to a master port, false otherwise
    prop.forwardAddrRegionToMasterPort = NULL; //master port of the  same component to which this slave port's addr region is forwarded
    transIf->setProperties(&prop);
}

/************************
 * IDCT Factory class
 ***********************/

class IDCTFactory : public MxFactory
{
public:
    IDCTFactory() : MxFactory ( "IDCT" ) {}
    sc_mx_m_base *createInstance(sc_mx_m_base *c, const string &id)
    { 
        return new IDCT(c, id); 
    }
};

/**
 *  Entry point into the memory components (from SoC Designer)
 */
extern "C" void 
MxInit(void)
{
    new IDCTFactory();
}
