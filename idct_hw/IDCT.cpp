/*
 *    Class implementation of the SoC Designer component <IDCT>
 *
 *    This code has been generated by the SoC Designer Component Wizard.
 *    Copyright (c) 2004-2005 by ARM Limited, 2000-2004 by AXYS Design Automation Inc., Irvine, CA, USA and AXYS GmbH, Herzongenrath
 *
 */

#include "IDCT.h"

#include <stdio.h>


#include "ahb_s_TS.h"

#include "IDCT_MxDI.h"
const int c1=251 ; /* cos(pi/16)<<8 */
const int s1=50 ; /* sin(pi/16)<<8 */
const int c3=213 ; /* cos(3pi/16)<<8 */
const int s3=142 ; /* sin(3pi/16)<<8 */
const int r2c6=277; /* cos(6pi/16)*sqrt(2)<<9 */
const int r2s6=669;
const int r2=181; /* sqrt(2)<<7 */

void IDCT::onecycle(int i){
  MxU32 x0,x1,x2,x3,x4,x5,x6,x7,x8;
  /* Stage 4 */
  if(i<8){
      x0=data[i*8+0]<<9, x1=data[i*8+1]<<7, x2=data[i*8+2],
      x3=data[i*8+3]*r2, x4=data[i*8+4]<<9, x5=data[i*8+5]*r2,
      x6=data[i*8+6], x7=data[i*8+7]<<7;
      x8=x7+x1; x1 -= x7;
      /* Stage 3 */
      x7=x0+x4; x0-=x4; x4=x1+x5; x1-=x5; x5=x3+x8; x8-=x3;
      x3=r2c6*(x2+x6);x6=x3+(-r2c6-r2s6)*x6;x2=x3+(-r2c6+r2s6)*x2;
      /* Stage 2 */
      x3=x7+x2; x7-=x2; x2=x0+x6; x0-= x6;
      x6=c3*(x4+x5);x5=(x6+(-c3-s3)*x5)>>6;x4=(x6+(-c3+s3)*x4)>>6;
      x6=c1*(x1+x8);x1=(x6+(-c1-s1)*x1)>>6;x8=(x6+(-c1+s1)*x8)>>6;
      /* Stage 1, rounding and output */
      x7+=512; x2+=512;x0+=512;x3+=512;
      data[i*8+0]=(x3+x4)>>10; data[i*8+1]=(x2+x8)>>10;
      data[i*8+2]=(x0+x1)>>10; data[i*8+3]=(x7+x5)>>10;
      data[i*8+4]=(x7-x5)>>10; data[i*8+5]=(x0-x1)>>10;
      data[i*8+6]=(x2-x8)>>10; data[i*8+7]=(x3-x4)>>10;
  }
  else{
      x0=data[i-8+0]<<9, x1=data[i-8+8]<<7, x2=data[i-8+16],
      x3=data[i-8+24]*r2, x4=data[i-8+32]<<9, x5=data[i-8+40]*r2,
      x6=data[i-8+48], x7=data[i-8+56]<<7;
      x8=x7+x1; x1 -= x7;
      /* Stage 3 */
      x7=x0+x4; x0-=x4; x4=x1+x5; x1-=x5; x5=x3+x8; x8-=x3;
      x3=r2c6*(x2+x6);x6=x3+(-r2c6-r2s6)*x6;x2=x3+(-r2c6+r2s6)*x2;
      /* Stage 2 */
      x3=x7+x2; x7-=x2; x2=x0+x6; x0-= x6;
      x6=c3*(x4+x5);x5=(x6+(-c3-s3)*x5)>>6;x4=(x6+(-c3+s3)*x4)>>6;
      x6=c1*(x1+x8);x1=(x6+(-c1-s1)*x1)>>6;x8=(x6+(-c1+s1)*x8)>>6;
      /* Stage 1, rounding and output */
      x7+=512; x2+=512;x0+=512;x3+=512;
      data[i-8+0]=(x3+x4)>>11; data[i-8+8]=(x2+x8)>>11;
      data[i-8+16]=(x0+x1)>>11; data[i-8+24]=(x7+x5)>>11;
      data[i-8+32]=(x7-x5)>>11; data[i-8+40]=(x0-x1)>>11;
      data[i-8+48]=(x2-x8)>>11; data[i-8+56]=(x3-x4)>>11;
  }
}


IDCT::IDCT(sc_mx_m_base* c, const string &s) : sc_mx_module(c, s)
{
    initComplete = false;

    ahb_s_TSlave = new ahb_s_TS( this );
    registerPort( ahb_s_TSlave, "ahb_s" );

    // Clocking the components
    SC_MX_CLOCKED();
    // Register ourself as a clock slave port.
    registerPort( dynamic_cast< sc_mx_clock_slave_p_base* >( this ), "clk-in");


    mxdi = NULL; 

    // Place parameter definitions here:
    defineParameter( "Enable Debug Messages", "false", MX_PARAM_BOOL);
    defineParameter( "ahb_s_addrSize", "0x100000000", MX_PARAM_VALUE, 0);
    defineParameter( "ahb_s_baseAddress", "0x0", MX_PARAM_VALUE, 0);

}

IDCT::~IDCT()
{

    delete ahb_s_TSlave;

}

void
IDCT::communicate()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing communicate function");
	}
#endif

	// TODO:  Add your communicate code here.
	// ...
printf("communicate\n");
if(r_status == IDCTBUSY)
    {
        if(calc_counter == 0)
        {
            printf("communicate initial\n");
            data[0]  =  r_reg0;
            data[1]  =  r_reg1;
            data[2]  =  r_reg2;
            data[3]  =  r_reg3;
            data[4]  =  r_reg4;
            data[5]  =  r_reg5;
            data[6]  =  r_reg6;
            data[7]  =  r_reg7;
            data[8]  =  r_reg8;
            data[9]  =  r_reg9;
            data[10] =  r_reg10;
            data[11] =  r_reg11;
            data[12] =  r_reg12;
            data[13] =  r_reg13;
            data[14] =  r_reg14;
            data[15] =  r_reg15;
            data[16] =  r_reg16;
            data[17] =  r_reg17;
            data[18] =  r_reg18;
            data[19] =  r_reg19;
            data[20] =  r_reg20;
            data[21] =  r_reg21;
            data[22] =  r_reg22;
            data[23] =  r_reg23;
            data[24] =  r_reg24;
            data[25] =  r_reg25;
            data[26] =  r_reg26;
            data[27] =  r_reg27;
            data[28] =  r_reg28;
            data[29] =  r_reg29;
            data[30] =  r_reg30;
            data[31] =  r_reg31;
            data[32] =  r_reg32;
            data[33] =  r_reg33;
            data[34] =  r_reg34;
            data[35] =  r_reg35;
            data[36] =  r_reg36;
            data[37] =  r_reg37;
            data[38] =  r_reg38;
            data[39] =  r_reg39;
            data[40] =  r_reg40;
            data[41] =  r_reg41;
            data[42] =  r_reg42;
            data[43] =  r_reg43;
            data[44] =  r_reg44;
            data[45] =  r_reg45;
            data[46] =  r_reg46;
            data[47] =  r_reg47;
            data[48] =  r_reg48;
            data[49] =  r_reg49;
            data[50] =  r_reg50;
            data[51] =  r_reg51;
            data[52] =  r_reg52;
            data[53] =  r_reg53;
            data[54] =  r_reg54;
            data[55] =  r_reg55;
            data[56] =  r_reg56;
            data[57] =  r_reg57;
            data[58] =  r_reg58;
            data[59] =  r_reg59;
            data[60] =  r_reg60;
            data[61] =  r_reg61;
            data[62] =  r_reg62;
            data[63] =  r_reg63;

        }
        onecycle(calc_counter);
        calc_counter++;
        printf("one cycle, calc_counter: %d\n", calc_counter);
    }
}

void
IDCT::update()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing update function");
	}
#endif
printf("update\n");
    switch(r_ctrl)
    {
        case IDCTSTART:
            calc_counter = 0;
            r_status = IDCTBUSY;
            r_ctrl = IDCTNOOP;
            break;

        default:
            if(r_status == IDCTBUSY)
            {
                if(calc_counter == 16)
                {
                    r_reg0 = data[0];
                    r_reg1 = data[1];
                    r_reg2 = data[2];
                    r_reg3 = data[3];
                    r_reg4 = data[4];
                    r_reg5 = data[5];
                    r_reg6 = data[6];
                    r_reg7 = data[7];
                    r_reg8 = data[8];
                    r_reg9 = data[9];
                    r_reg10 = data[10];
                    r_reg11 = data[11];
                    r_reg12 = data[12];
                    r_reg13 = data[13];
                    r_reg14 = data[14];
                    r_reg15 = data[15];
                    r_reg16 = data[16];
                    r_reg17 = data[17];
                    r_reg18 = data[18];
                    r_reg19 = data[19];
                    r_reg20 = data[20];
                    r_reg21 = data[21];
                    r_reg22 = data[22];
                    r_reg23 = data[23];
                    r_reg24 = data[24];
                    r_reg25 = data[25];
                    r_reg26 = data[26];
                    r_reg27 = data[27];
                    r_reg28 = data[28];
                    r_reg29 = data[29];
                    r_reg30 = data[30];
                    r_reg31 = data[31];
                    r_reg32 = data[32];
                    r_reg33 = data[33];
                    r_reg34 = data[34];
                    r_reg35 = data[35];
                    r_reg36 = data[36];
                    r_reg37 = data[37];
                    r_reg38 = data[38];
                    r_reg39 = data[39];
                    r_reg40 = data[40];
                    r_reg41 = data[41];
                    r_reg42 = data[42];
                    r_reg43 = data[43];
                    r_reg44 = data[44];
                    r_reg45 = data[45];
                    r_reg46 = data[46];
                    r_reg47 = data[47];
                    r_reg48 = data[48];
                    r_reg49 = data[49];
                    r_reg50 = data[50];
                    r_reg51 = data[51];
                    r_reg52 = data[52];
                    r_reg53 = data[53];
                    r_reg54 = data[54];
                    r_reg55 = data[55];
                    r_reg56 = data[56];
                    r_reg57 = data[57];
                    r_reg58 = data[58];
                    r_reg59 = data[59];
                    r_reg60 = data[60];
                    r_reg61 = data[61];
                    r_reg62 = data[62];
                    r_reg63 = data[63];

                    r_status = IDCTIDLE;
                }
                else if (calc_counter >16)
                    r_status = IDCTIDLE;
                //r_status = MD5IDLE;
            }
            break;
    }
	 // TODO:  Add your update code here.
	 // ...
}

void 
IDCT::init()
{

   // Create MXDI Interface
    mxdi = new IDCT_MxDI(this);
    r_reg0 = 0;
    r_reg1 = 0;
    r_reg2 = 0;
    r_reg3 = 0;
    r_reg4 = 0;
    r_reg5 = 0;
    r_reg6 = 0;
    r_reg7 = 0;
    r_reg8 = 0;
    r_reg9 = 0;
    r_reg10 = 0;
    r_reg11 = 0;
    r_reg12 = 0;
    r_reg13 = 0;
    r_reg14 = 0;
    r_reg15 = 0;
    r_reg16 = 0;
    r_reg17 = 0;
    r_reg18 = 0;
    r_reg19 = 0;
    r_reg20 = 0;
    r_reg21 = 0;
    r_reg22 = 0;
    r_reg23 = 0;
    r_reg24 = 0;
    r_reg25 = 0;
    r_reg26 = 0;
    r_reg27 = 0;
    r_reg28 = 0;
    r_reg29 = 0;
    r_reg30 = 0;
    r_reg31 = 0;
    r_reg32 = 0;
    r_reg33 = 0;
    r_reg34 = 0;
    r_reg35 = 0;
    r_reg36 = 0;
    r_reg37 = 0;
    r_reg38 = 0;
    r_reg39 = 0;
    r_reg40 = 0;
    r_reg41 = 0;
    r_reg42 = 0;
    r_reg43 = 0;
    r_reg44 = 0;
    r_reg45 = 0;
    r_reg46 = 0;
    r_reg47 = 0;
    r_reg48 = 0;
    r_reg49 = 0;
    r_reg50 = 0;
    r_reg51 = 0;
    r_reg52 = 0;
    r_reg53 = 0;
    r_reg54 = 0;
    r_reg55 = 0;
    r_reg56 = 0;
    r_reg57 = 0;
    r_reg58 = 0;
    r_reg59 = 0;
    r_reg60 = 0;
    r_reg61 = 0;
    r_reg62 = 0;
    r_reg63 = 0;
    r_ctrl = 0;
    r_status = 0;

	
    // Initialize ourself for save/restore.
    initStream( this );


    // Allocate memory and initialize data here:
    // ...
  
    // Call the base class after this has been initialized.
    sc_mx_module::init();

    // Set a flag that init stage has been completed
    initComplete = true;
}

void
IDCT::reset(MxResetLevel level, const MxFileMapIF *filelist)
{
    // Add your reset behavior here:
    // ...



    // Call the base class after this has been reset.
    sc_mx_module::reset(level, filelist);
}

void 
IDCT::terminate()
{
    // Call the base class first.
    sc_mx_module::terminate();

    // Release the MXDI Interface
    if(mxdi!=NULL) {delete mxdi; mxdi=NULL;}

    // Free memory which has been allocated in init stage
    // ...
}

void
IDCT::setParameter( const string &name, const string &value )
{
    MxConvertErrorCodes status = MxConvert_SUCCESS;

    if (name == "Enable Debug Messages")
    {
        status = MxConvertStringToValue( value, &p_enableDbgMsg  );
    }
    else if (name == "ahb_s_addrSize")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_s_addrSize );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }
    else if (name == "ahb_s_baseAddress")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_s_baseAddress );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }

    if ( status == MxConvert_SUCCESS )
    {
        sc_mx_module::setParameter(name, value);
    }
    else
    {
        message( MX_MSG_WARNING, "IDCT::setParameter: Illegal value <%s> "
		 "passed for parameter <%s>. Assignment ignored.", value.c_str(), name.c_str() );
    }
}

string
IDCT::getProperty( MxPropertyType property )
{
    string description; 
    switch ( property ) 
    {    
	 case MX_PROP_LOADFILE_EXTENSION:
		return "";
	 case MX_PROP_REPORT_FILE_EXT:
		return "yes";
	 case MX_PROP_COMPONENT_TYPE:
		return "Other"; 
	 case MX_PROP_COMPONENT_VERSION:
		return "0.1";
	 case MX_PROP_MSG_PREPEND_NAME:
		return "yes"; 
	 case MX_PROP_DESCRIPTION:
		description = "";
		return description + " Compiled on " + __DATE__ + ", " + __TIME__; 
	 case MX_PROP_MXDI_SUPPORT:
		return "yes";
	 case MX_PROP_SAVE_RESTORE:
		return "yes";
	 default:
		return "";
    }
}

string
IDCT::getName(void)
{
    return "IDCT";
}

MXDI*
IDCT::getMxDI()
{
    return mxdi;
}


bool
IDCT::saveData( MxODataStream &data )
{
    data << r_reg0;
    data << r_reg1;
    data << r_reg2;
    data << r_reg3;
    data << r_reg4;
    data << r_reg5;
    data << r_reg6;
    data << r_reg7;
    data << r_reg8;
    data << r_reg9;
    data << r_reg10;
    data << r_reg11;
    data << r_reg12;
    data << r_reg13;
    data << r_reg14;
    data << r_reg15;
    data << r_reg16;
    data << r_reg17;
    data << r_reg18;
    data << r_reg19;
    data << r_reg20;
    data << r_reg21;
    data << r_reg22;
    data << r_reg23;
    data << r_reg24;
    data << r_reg25;
    data << r_reg26;
    data << r_reg27;
    data << r_reg28;
    data << r_reg29;
    data << r_reg30;
    data << r_reg31;
    data << r_reg32;
    data << r_reg33;
    data << r_reg34;
    data << r_reg35;
    data << r_reg36;
    data << r_reg37;
    data << r_reg38;
    data << r_reg39;
    data << r_reg40;
    data << r_reg41;
    data << r_reg42;
    data << r_reg43;
    data << r_reg44;
    data << r_reg45;
    data << r_reg46;
    data << r_reg47;
    data << r_reg48;
    data << r_reg49;
    data << r_reg50;
    data << r_reg51;
    data << r_reg52;
    data << r_reg53;
    data << r_reg54;
    data << r_reg55;
    data << r_reg56;
    data << r_reg57;
    data << r_reg58;
    data << r_reg59;
    data << r_reg60;
    data << r_reg61;
    data << r_reg62;
    data << r_reg63;
    data << r_ctrl;
    data << r_status;


    // TODO: Add your save code here.
    // Below line shows how the example state variable is saved. 
    // data << exampleStateVariable;


    // return save was successful
	return true;
}

bool
IDCT::restoreData( MxIDataStream &data )
{
    data >> r_reg0;
    data >> r_reg1;
    data >> r_reg2;
    data >> r_reg3;
    data >> r_reg4;
    data >> r_reg5;
    data >> r_reg6;
    data >> r_reg7;
    data >> r_reg8;
    data >> r_reg9;
    data >> r_reg10;
    data >> r_reg11;
    data >> r_reg12;
    data >> r_reg13;
    data >> r_reg14;
    data >> r_reg15;
    data >> r_reg16;
    data >> r_reg17;
    data >> r_reg18;
    data >> r_reg19;
    data >> r_reg20;
    data >> r_reg21;
    data >> r_reg22;
    data >> r_reg23;
    data >> r_reg24;
    data >> r_reg25;
    data >> r_reg26;
    data >> r_reg27;
    data >> r_reg28;
    data >> r_reg29;
    data >> r_reg30;
    data >> r_reg31;
    data >> r_reg32;
    data >> r_reg33;
    data >> r_reg34;
    data >> r_reg35;
    data >> r_reg36;
    data >> r_reg37;
    data >> r_reg38;
    data >> r_reg39;
    data >> r_reg40;
    data >> r_reg41;
    data >> r_reg42;
    data >> r_reg43;
    data >> r_reg44;
    data >> r_reg45;
    data >> r_reg46;
    data >> r_reg47;
    data >> r_reg48;
    data >> r_reg49;
    data >> r_reg50;
    data >> r_reg51;
    data >> r_reg52;
    data >> r_reg53;
    data >> r_reg54;
    data >> r_reg55;
    data >> r_reg56;
    data >> r_reg57;
    data >> r_reg58;
    data >> r_reg59;
    data >> r_reg60;
    data >> r_reg61;
    data >> r_reg62;
    data >> r_reg63;
    data >> r_ctrl;
    data >> r_status;


    // TODO: Add your restore code here.
    // Below line shows how the example state variable is saved. 
    // data >> exampleStateVariable;


    // return restore was successful
	return true;
}

void
IDCT::initSignalPort(sc_mx_signal_p_base* signalIf)
{
    MxSignalProperties prop_sm1;
    memset(&prop_sm1,0,sizeof(prop_sm1));
    prop_sm1.isOptional=false;
    prop_sm1.bitwidth=32;
    signalIf->setProperties(&prop_sm1);
}

// This initTransactionPort() is only called for Transaction Master Ports.
// Do not call this function for any port which has its own initialization code.
void
IDCT::initTransactionPort(sc_mx_transaction_p_base* transIf)
{
    MxTransactionProperties prop;
    memset(&prop,0,sizeof(prop));
    prop.mxsiVersion = MXSI_VERSION_6;     //the transaction version used for this transaction
    prop.useMultiCycleInterface = false;    // using read/write interface methods
    prop.addressBitwidth = 32;      // address bitwidth used for addressing of resources 
    prop.mauBitwidth = 8;           // minimal addressable unit 
    prop.dataBitwidth = 32;         // maximum data bitwidth transferred in a single cycle 
    prop.isLittleEndian = true;     // alignment of MAUs 
    prop.isOptional = false;				// if true this port can be disabled 
    prop.supportsAddressRegions = true;	// M/S can negotiate address mapping
    prop.numCtrlFields = 1;         // # of ctrl elements used / entry is used for transfer size
    prop.protocolID = 0x00000001;           // magic number of the protocol (Vendor/Protocol-ID): 
				                             //The upper 16 bits = protocol implementation version
											//The lower 16 bits = actual protocol ID
    sprintf(prop.protocolName,"Mx");         // The name of the  protocol being used
    // MxSI 6.0: slave port address regions forwarding 
    prop.isAddrRegionForwarded = false; //true if addr region for this slave port is actually 
											//forwarded to a master port, false otherwise
    prop.forwardAddrRegionToMasterPort = NULL; //master port of the  same component to which this slave port's addr region is forwarded
    transIf->setProperties(&prop);
}

/************************
 * IDCT Factory class
 ***********************/

class IDCTFactory : public MxFactory
{
public:
    IDCTFactory() : MxFactory ( "IDCT" ) {}
    sc_mx_m_base *createInstance(sc_mx_m_base *c, const string &id)
    { 
        return new IDCT(c, id); 
    }
};

/**
 *  Entry point into the memory components (from SoC Designer)
 */
extern "C" void 
MxInit(void)
{
    new IDCTFactory();
}
