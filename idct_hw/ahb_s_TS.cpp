/*
 *    Class implementation of ahb_s port for component <IDCT>
 *
 *    This code has been generated by the SoC Designer Component Wizard.
 *    Copyright (c) 2004-2005 by ARM Limited, 2000-2004 by AXYS Design Automation Inc., Irvine, CA, USA and AXYS GmbH, Herzongenrath
 *
 */

#include "ahb_s_TS.h"
#include "IDCT.h"
#include "AHB_Transaction.h"


ahb_s_TS::ahb_s_TS( IDCT *_owner ) : sc_mx_transaction_slave( "ahb_s_TS" )

{
	owner = _owner;
	setMxOwner(owner);

	MxTransactionProperties prop;
	memset(&prop,0,sizeof(prop));
	AHB_INIT_TRANSACTION_PROPERTIES(prop);
	setProperties(&prop);

	// Memory Map
	// TODO: Add the constraints 
	puMemoryMapConstraints.minRegionSize = 0x1000;
	puMemoryMapConstraints.maxRegionSize = MxU64CONST(0x100000000);
	puMemoryMapConstraints.minAddress = 0x0;
	puMemoryMapConstraints.maxAddress = MxU64CONST(0xffffffff);
	puMemoryMapConstraints.minNumSupportedRegions = 0x1; 
	puMemoryMapConstraints.maxNumSupportedRegions = 0x1;
	puMemoryMapConstraints.alignmentBlockSize = 0x400 ; //the min block size where this slave's regions can be mapped 
	puMemoryMapConstraints.numFixedRegions = 0; 
	puMemoryMapConstraints.fixedRegionList = NULL;  

	// set base addr name
	p_baseAddrName = "baseAddress";

	
	// TODO:  Add any additional constructor code here.
}

/* If no regions are defined, numRegions returns 0, indicating that the 
 * port wants to be called for any MxU64 address */
int
ahb_s_TS::getNumRegions()
{
	// TODO:  Add your code here.

	return 1;
}

/* This function is also not pure virtual, so that the user
 * does not need to implement it if she/he doesn't want to use 
 * address mapping */
void 
ahb_s_TS::getAddressRegions(MxU64* start, MxU64* size, string* name)
{
	if (start && size && name) {
		start[0] = owner->p_ahb_s_baseAddress;
		size[0]  = owner->p_ahb_s_addrSize;
		name[0] = p_baseAddrName;
	}

    // TODO: Add your code here.

}

/* Method to set the address regions */
//Sets the value of the address regions for this slave port
void
ahb_s_TS::setAddressRegions(MxU64* start, MxU64* size, string* name)
{
	// Memory Map Editor Support
	if (start && size && name)
	{
		int i = 0;
		while (size[i] != 0 )
		{
			if (i == 0) {
				owner->p_ahb_s_baseAddress = start[i]; 
				owner->p_ahb_s_addrSize = size[i];
				p_baseAddrName = name[i];
			} else {
				//TODO: Add your code here.
			}
#ifdef _DEBUG_
		owner->message(MX_MSG_INFO, "Address Region: start= 0x%I64x size = 0x%I64x Name= %s",
			start[i], size[i],
			name[i].c_str());
#endif
			i++;
		}
	}
}

MxMemoryMapConstraints* 
ahb_s_TS::getMappingConstraints() 
{
	return &puMemoryMapConstraints;
}

MxStatus 
ahb_s_TS::read(MxU64 addr, MxU32* value, MxU32* ctrl)
{

	MxStatus status = MX_STATUS_OK; // return status
	ctrl[AHB_IDX_ACK] = AHB_ACK_DONE;

	if (ctrl[AHB_IDX_CYCLE] == AHB_CYCLE_ADDR) {              /* address phase */
		// TODO: Add your code here.
       } else if (ctrl[AHB_IDX_CYCLE] == AHB_CYCLE_DATA) {       /* data phase */
		
		// ctrl[AHB_IDX_TYPE] represents hsize[2:0] which includes
		// MX_TYPE_BYTE = 8 bits, MX_TYPE_HWORD = 16 bits,
		// MX_TYPE_WORD = 32 bits,MX_TYPE_DWORD = 64 bits,
		// MX_TYPE_128BIT = 128 bits, MX_TYPE_256BIT = 256 bits,
		// MX_TYPE_512BIT = 512 bits, MX_TYPE_1024BIT = 1024 bits.

		// TODO: Add your code here.
		MxU64 offset = addr - owner->p_ahb_s_baseAddress;
		switch(offset) {
			case 0:
				value[0] = owner->r_status;
				break;

			case 4:
				value[0] = owner->r_ctrl;
				break;

			case 8:
			    value[0] = owner->r_reg0; break;
			case 12:
			    value[0] = owner->r_reg1; break;
			case 16:
			    value[0] = owner->r_reg2; break;
			case 20:
			    value[0] = owner->r_reg3; break;
			case 24:
			    value[0] = owner->r_reg4; break;
			case 28:
			    value[0] = owner->r_reg5; break;
			case 32:
			    value[0] = owner->r_reg6; break;
			case 36:
			    value[0] = owner->r_reg7; break;
			case 40:
			    value[0] = owner->r_reg8; break;
			case 44:
			    value[0] = owner->r_reg9; break;
			case 48:
			    value[0] = owner->r_reg10; break;
			case 52:
			    value[0] = owner->r_reg11; break;
			case 56:
			    value[0] = owner->r_reg12; break;
			case 60:
			    value[0] = owner->r_reg13; break;
			case 64:
			    value[0] = owner->r_reg14; break;
			case 68:
			    value[0] = owner->r_reg15; break;
			case 72:
			    value[0] = owner->r_reg16; break;
			case 76:
			    value[0] = owner->r_reg17; break;
			case 80:
			    value[0] = owner->r_reg18; break;
			case 84:
			    value[0] = owner->r_reg19; break;
			case 88:
			    value[0] = owner->r_reg20; break;
			case 92:
			    value[0] = owner->r_reg21; break;
			case 96:
			    value[0] = owner->r_reg22; break;
			case 100:
			    value[0] = owner->r_reg23; break;
			case 104:
			    value[0] = owner->r_reg24; break;
			case 108:
			    value[0] = owner->r_reg25; break;
			case 112:
			    value[0] = owner->r_reg26; break;
			case 116:
			    value[0] = owner->r_reg27; break;
			case 120:
			    value[0] = owner->r_reg28; break;
			case 124:
			    value[0] = owner->r_reg29; break;
			case 128:
			    value[0] = owner->r_reg30; break;
			case 132:
			    value[0] = owner->r_reg31; break;
			case 136:
			    value[0] = owner->r_reg32; break;
			case 140:
			    value[0] = owner->r_reg33; break;
			case 144:
			    value[0] = owner->r_reg34; break;
			case 148:
			    value[0] = owner->r_reg35; break;
			case 152:
			    value[0] = owner->r_reg36; break;
			case 156:
			    value[0] = owner->r_reg37; break;
			case 160:
			    value[0] = owner->r_reg38; break;
			case 164:
			    value[0] = owner->r_reg39; break;
			case 168:
			    value[0] = owner->r_reg40; break;
			case 172:
			    value[0] = owner->r_reg41; break;
			case 176:
			    value[0] = owner->r_reg42; break;
			case 180:
			    value[0] = owner->r_reg43; break;
			case 184:
			    value[0] = owner->r_reg44; break;
			case 188:
			    value[0] = owner->r_reg45; break;
			case 192:
			    value[0] = owner->r_reg46; break;
			case 196:
			    value[0] = owner->r_reg47; break;
			case 200:
			    value[0] = owner->r_reg48; break;
			case 204:
			    value[0] = owner->r_reg49; break;
			case 208:
			    value[0] = owner->r_reg50; break;
			case 212:
			    value[0] = owner->r_reg51; break;
			case 216:
			    value[0] = owner->r_reg52; break;
			case 220:
			    value[0] = owner->r_reg53; break;
			case 224:
			    value[0] = owner->r_reg54; break;
			case 228:
			    value[0] = owner->r_reg55; break;
			case 232:
			    value[0] = owner->r_reg56; break;
			case 236:
			    value[0] = owner->r_reg57; break;
			case 240:
			    value[0] = owner->r_reg58; break;
			case 244:
			    value[0] = owner->r_reg59; break;
			case 248:
			    value[0] = owner->r_reg60; break;
			case 252:
			    value[0] = owner->r_reg61; break;
			case 256:
			    value[0] = owner->r_reg62; break;
			case 260:
			    value[0] = owner->r_reg63; break;
			default:break;
			}
#ifdef _DEBUG_
		if (owner->p_enableDbgMsg) {
			owner->message(MX_MSG_DEBUG, "%s: DATA_CYCLE READ(AHB_ACK_DONE) addr:0x%08x data:0x%08x",
				owner->getInstanceID().c_str(), (MxU32)addr, *value);
		}
#endif
	}
	return status;
}

MxStatus 
ahb_s_TS::write(MxU64 addr, MxU32* value, MxU32* ctrl)
{

	MxStatus status = MX_STATUS_OK; // return status
	ctrl[AHB_IDX_ACK] = AHB_ACK_DONE;

	if (ctrl[AHB_IDX_CYCLE] == AHB_CYCLE_ADDR) {              /* address phase */
		// TODO: Add your code here.
	} else if (ctrl[AHB_IDX_CYCLE] == AHB_CYCLE_DATA) {       /* data phase */
		

		// ctrl[AHB_IDX_TYPE] represents hsize[2:0] which includes
		// MX_TYPE_BYTE = 8 bits, MX_TYPE_HWORD = 16 bits,
		// MX_TYPE_WORD = 32 bits,MX_TYPE_DWORD = 64 bits,
		// MX_TYPE_128BIT = 128 bits, MX_TYPE_256BIT = 256 bits,
		// MX_TYPE_512BIT = 512 bits, MX_TYPE_1024BIT = 1024 bits.

		// TODO: Add your code here.

		MxU64 offset = addr - owner->p_ahb_s_baseAddress;
		switch(offset) {
			case 0:
				owner->r_status = value[0]; break;
			case 8:
			    owner->r_reg0 = value[0]; break;
			case 12:
			    owner->r_reg1 = value[0]; break;
			case 16:
			    owner->r_reg2 = value[0]; break;
			case 20:
			    owner->r_reg3 = value[0]; break;
			case 24:
			    owner->r_reg4 = value[0]; break;
			case 28:
			    owner->r_reg5 = value[0]; break;
			case 32:
			    owner->r_reg6 = value[0]; break;
			case 36:
			    owner->r_reg7 = value[0]; break;
			case 40:
			    owner->r_reg8 = value[0]; break;
			case 44:
			    owner->r_reg9 = value[0]; break;
			case 48:
			    owner->r_reg10 = value[0]; break;
			case 52:
			    owner->r_reg11 = value[0]; break;
			case 56:
			    owner->r_reg12 = value[0]; break;
			case 60:
			    owner->r_reg13 = value[0]; break;
			case 64:
			    owner->r_reg14 = value[0]; break;
			case 68:
			    owner->r_reg15 = value[0]; break;
			case 72:
			    owner->r_reg16 = value[0]; break;
			case 76:
			    owner->r_reg17 = value[0]; break;
			case 80:
			    owner->r_reg18 = value[0]; break;
			case 84:
			    owner->r_reg19 = value[0]; break;
			case 88:
			    owner->r_reg20 = value[0]; break;
			case 92:
			    owner->r_reg21 = value[0]; break;
			case 96:
			    owner->r_reg22 = value[0]; break;
			case 100:
			    owner->r_reg23 = value[0]; break;
			case 104:
			    owner->r_reg24 = value[0]; break;
			case 108:
			    owner->r_reg25 = value[0]; break;
			case 112:
			    owner->r_reg26 = value[0]; break;
			case 116:
			    owner->r_reg27 = value[0]; break;
			case 120:
			    owner->r_reg28 = value[0]; break;
			case 124:
			    owner->r_reg29 = value[0]; break;
			case 128:
			    owner->r_reg30 = value[0]; break;
			case 132:
			    owner->r_reg31 = value[0]; break;
			case 136:
			    owner->r_reg32 = value[0]; break;
			case 140:
			    owner->r_reg33 = value[0]; break;
			case 144:
			    owner->r_reg34 = value[0]; break;
			case 148:
			    owner->r_reg35 = value[0]; break;
			case 152:
			    owner->r_reg36 = value[0]; break;
			case 156:
			    owner->r_reg37 = value[0]; break;
			case 160:
			    owner->r_reg38 = value[0]; break;
			case 164:
			    owner->r_reg39 = value[0]; break;
			case 168:
			    owner->r_reg40 = value[0]; break;
			case 172:
			    owner->r_reg41 = value[0]; break;
			case 176:
			    owner->r_reg42 = value[0]; break;
			case 180:
			    owner->r_reg43 = value[0]; break;
			case 184:
			    owner->r_reg44 = value[0]; break;
			case 188:
			    owner->r_reg45 = value[0]; break;
			case 192:
			    owner->r_reg46 = value[0]; break;
			case 196:
			    owner->r_reg47 = value[0]; break;
			case 200:
			    owner->r_reg48 = value[0]; break;
			case 204:
			    owner->r_reg49 = value[0]; break;
			case 208:
			    owner->r_reg50 = value[0]; break;
			case 212:
			    owner->r_reg51 = value[0]; break;
			case 216:
			    owner->r_reg52 = value[0]; break;
			case 220:
			    owner->r_reg53 = value[0]; break;
			case 224:
			    owner->r_reg54 = value[0]; break;
			case 228:
			    owner->r_reg55 = value[0]; break;
			case 232:
			    owner->r_reg56 = value[0]; break;
			case 236:
			    owner->r_reg57 = value[0]; break;
			case 240:
			    owner->r_reg58 = value[0]; break;
			case 244:
			    owner->r_reg59 = value[0]; break;
			case 248:
			    owner->r_reg60 = value[0]; break;
			case 252:
			    owner->r_reg61 = value[0]; break;
			case 256:
			    owner->r_reg62 = value[0]; break;
			case 260:
			    owner->r_reg63 = value[0]; break;
			default:break;
		}
#ifdef _DEBUG_
		if (owner->p_enableDbgMsg) {
			owner->message(MX_MSG_DEBUG, "%s: DATA_CYCLE WRITE(AHB_ACK_DONE) addr:0x%08x data:0x%08x",
				owner->getInstanceID().c_str(), (MxU32)addr, *value);
		}
#endif
	}
	return status;
}

MxStatus 
ahb_s_TS::readDbg(MxU64 addr, MxU32* value, MxU32* ctrl)
{

	// ctrl[AHB_IDX_TYPE] represents hsize[2:0] which includes
	// AHB_TYPE_BYTE = 8 bits, AHB_TYPE_HWORD = 16 bits,
	// AHB_TYPE_WORD = 32 bits,AHB_TYPE_DWORD = 64 bits,
	// AHB_TYPE_128BIT = 128 bits, AHB_TYPE_256BIT = 256 bits,
	// AHB_TYPE_512BIT = 512 bits, AHB_TYPE_1024BIT = 1024 bits.
	// All other fields can be ignored in a debug access.

	// Put the requested amount of data into *value.
	// Change the return value to MX_STATUS_OK to accept debug read accesses.
    // TODO: Add your code here.
	MxU64 offset = addr - owner->p_ahb_s_baseAddress;
		switch(offset) {
			case 0:
				value[0] = owner->r_status;
				break;

			case 4:
				value[0] = owner->r_ctrl;
				break;

			case 8:
			    value[0] = owner->r_reg0; break;
			case 12:
			    value[0] = owner->r_reg1; break;
			case 16:
			    value[0] = owner->r_reg2; break;
			case 20:
			    value[0] = owner->r_reg3; break;
			case 24:
			    value[0] = owner->r_reg4; break;
			case 28:
			    value[0] = owner->r_reg5; break;
			case 32:
			    value[0] = owner->r_reg6; break;
			case 36:
			    value[0] = owner->r_reg7; break;
			case 40:
			    value[0] = owner->r_reg8; break;
			case 44:
			    value[0] = owner->r_reg9; break;
			case 48:
			    value[0] = owner->r_reg10; break;
			case 52:
			    value[0] = owner->r_reg11; break;
			case 56:
			    value[0] = owner->r_reg12; break;
			case 60:
			    value[0] = owner->r_reg13; break;
			case 64:
			    value[0] = owner->r_reg14; break;
			case 68:
			    value[0] = owner->r_reg15; break;
			case 72:
			    value[0] = owner->r_reg16; break;
			case 76:
			    value[0] = owner->r_reg17; break;
			case 80:
			    value[0] = owner->r_reg18; break;
			case 84:
			    value[0] = owner->r_reg19; break;
			case 88:
			    value[0] = owner->r_reg20; break;
			case 92:
			    value[0] = owner->r_reg21; break;
			case 96:
			    value[0] = owner->r_reg22; break;
			case 100:
			    value[0] = owner->r_reg23; break;
			case 104:
			    value[0] = owner->r_reg24; break;
			case 108:
			    value[0] = owner->r_reg25; break;
			case 112:
			    value[0] = owner->r_reg26; break;
			case 116:
			    value[0] = owner->r_reg27; break;
			case 120:
			    value[0] = owner->r_reg28; break;
			case 124:
			    value[0] = owner->r_reg29; break;
			case 128:
			    value[0] = owner->r_reg30; break;
			case 132:
			    value[0] = owner->r_reg31; break;
			case 136:
			    value[0] = owner->r_reg32; break;
			case 140:
			    value[0] = owner->r_reg33; break;
			case 144:
			    value[0] = owner->r_reg34; break;
			case 148:
			    value[0] = owner->r_reg35; break;
			case 152:
			    value[0] = owner->r_reg36; break;
			case 156:
			    value[0] = owner->r_reg37; break;
			case 160:
			    value[0] = owner->r_reg38; break;
			case 164:
			    value[0] = owner->r_reg39; break;
			case 168:
			    value[0] = owner->r_reg40; break;
			case 172:
			    value[0] = owner->r_reg41; break;
			case 176:
			    value[0] = owner->r_reg42; break;
			case 180:
			    value[0] = owner->r_reg43; break;
			case 184:
			    value[0] = owner->r_reg44; break;
			case 188:
			    value[0] = owner->r_reg45; break;
			case 192:
			    value[0] = owner->r_reg46; break;
			case 196:
			    value[0] = owner->r_reg47; break;
			case 200:
			    value[0] = owner->r_reg48; break;
			case 204:
			    value[0] = owner->r_reg49; break;
			case 208:
			    value[0] = owner->r_reg50; break;
			case 212:
			    value[0] = owner->r_reg51; break;
			case 216:
			    value[0] = owner->r_reg52; break;
			case 220:
			    value[0] = owner->r_reg53; break;
			case 224:
			    value[0] = owner->r_reg54; break;
			case 228:
			    value[0] = owner->r_reg55; break;
			case 232:
			    value[0] = owner->r_reg56; break;
			case 236:
			    value[0] = owner->r_reg57; break;
			case 240:
			    value[0] = owner->r_reg58; break;
			case 244:
			    value[0] = owner->r_reg59; break;
			case 248:
			    value[0] = owner->r_reg60; break;
			case 252:
			    value[0] = owner->r_reg61; break;
			case 256:
			    value[0] = owner->r_reg62; break;
			case 260:
			    value[0] = owner->r_reg63; break;
			default:break;
		}
//	return MX_STATUS_OK;
	return MX_STATUS_NOTSUPPORTED;

}

MxStatus 
ahb_s_TS::writeDbg(MxU64 addr, MxU32* value, MxU32* ctrl)
{

	// ctrl[AHB_IDX_TYPE] represents hsize[2:0] which includes
	// AHB_TYPE_BYTE = 8 bits, AHB_TYPE_HWORD = 16 bits,
	// AHB_TYPE_WORD = 32 bits,AHB_TYPE_DWORD = 64 bits,
	// AHB_TYPE_128BIT = 128 bits, AHB_TYPE_256BIT = 256 bits,
	// AHB_TYPE_512BIT = 512 bits, AHB_TYPE_1024BIT = 1024 bits.
	// All other fields can be ignored in a debug access.

	// Put the requested amount of data into *value.
	// Change the return value to MX_STATUS_OK to accept debug write accesses.
    // TODO: Add your code here.
	MxU64 offset = addr - owner->p_ahb_s_baseAddress;
		switch(offset) {
			case 0:
				owner->r_status = value[0]; break;
			case 8:
			    owner->r_reg0 = value[0]; break;
			case 12:
			    owner->r_reg1 = value[0]; break;
			case 16:
			    owner->r_reg2 = value[0]; break;
			case 20:
			    owner->r_reg3 = value[0]; break;
			case 24:
			    owner->r_reg4 = value[0]; break;
			case 28:
			    owner->r_reg5 = value[0]; break;
			case 32:
			    owner->r_reg6 = value[0]; break;
			case 36:
			    owner->r_reg7 = value[0]; break;
			case 40:
			    owner->r_reg8 = value[0]; break;
			case 44:
			    owner->r_reg9 = value[0]; break;
			case 48:
			    owner->r_reg10 = value[0]; break;
			case 52:
			    owner->r_reg11 = value[0]; break;
			case 56:
			    owner->r_reg12 = value[0]; break;
			case 60:
			    owner->r_reg13 = value[0]; break;
			case 64:
			    owner->r_reg14 = value[0]; break;
			case 68:
			    owner->r_reg15 = value[0]; break;
			case 72:
			    owner->r_reg16 = value[0]; break;
			case 76:
			    owner->r_reg17 = value[0]; break;
			case 80:
			    owner->r_reg18 = value[0]; break;
			case 84:
			    owner->r_reg19 = value[0]; break;
			case 88:
			    owner->r_reg20 = value[0]; break;
			case 92:
			    owner->r_reg21 = value[0]; break;
			case 96:
			    owner->r_reg22 = value[0]; break;
			case 100:
			    owner->r_reg23 = value[0]; break;
			case 104:
			    owner->r_reg24 = value[0]; break;
			case 108:
			    owner->r_reg25 = value[0]; break;
			case 112:
			    owner->r_reg26 = value[0]; break;
			case 116:
			    owner->r_reg27 = value[0]; break;
			case 120:
			    owner->r_reg28 = value[0]; break;
			case 124:
			    owner->r_reg29 = value[0]; break;
			case 128:
			    owner->r_reg30 = value[0]; break;
			case 132:
			    owner->r_reg31 = value[0]; break;
			case 136:
			    owner->r_reg32 = value[0]; break;
			case 140:
			    owner->r_reg33 = value[0]; break;
			case 144:
			    owner->r_reg34 = value[0]; break;
			case 148:
			    owner->r_reg35 = value[0]; break;
			case 152:
			    owner->r_reg36 = value[0]; break;
			case 156:
			    owner->r_reg37 = value[0]; break;
			case 160:
			    owner->r_reg38 = value[0]; break;
			case 164:
			    owner->r_reg39 = value[0]; break;
			case 168:
			    owner->r_reg40 = value[0]; break;
			case 172:
			    owner->r_reg41 = value[0]; break;
			case 176:
			    owner->r_reg42 = value[0]; break;
			case 180:
			    owner->r_reg43 = value[0]; break;
			case 184:
			    owner->r_reg44 = value[0]; break;
			case 188:
			    owner->r_reg45 = value[0]; break;
			case 192:
			    owner->r_reg46 = value[0]; break;
			case 196:
			    owner->r_reg47 = value[0]; break;
			case 200:
			    owner->r_reg48 = value[0]; break;
			case 204:
			    owner->r_reg49 = value[0]; break;
			case 208:
			    owner->r_reg50 = value[0]; break;
			case 212:
			    owner->r_reg51 = value[0]; break;
			case 216:
			    owner->r_reg52 = value[0]; break;
			case 220:
			    owner->r_reg53 = value[0]; break;
			case 224:
			    owner->r_reg54 = value[0]; break;
			case 228:
			    owner->r_reg55 = value[0]; break;
			case 232:
			    owner->r_reg56 = value[0]; break;
			case 236:
			    owner->r_reg57 = value[0]; break;
			case 240:
			    owner->r_reg58 = value[0]; break;
			case 244:
			    owner->r_reg59 = value[0]; break;
			case 248:
			    owner->r_reg60 = value[0]; break;
			case 252:
			    owner->r_reg61 = value[0]; break;
			case 256:
			    owner->r_reg62 = value[0]; break;
			case 260:
			    owner->r_reg63 = value[0]; break;
			default:break;
			}
//	return MX_STATUS_OK;
	return MX_STATUS_NOTSUPPORTED;
}

MxStatus 
ahb_s_TS::readReq(MxU64 addr, MxU32* value, MxU32* ctrl, MxTransactionCallbackIF* callback)
{
	UNUSEDARG(addr);
	UNUSEDARG(value);
	UNUSEDARG(callback);
        MxStatus ret = MX_STATUS_NOTSUPPORTED;

        if (ctrl)
        {
                // get a pointer to the central AHB signals structure
                // can be safely read in update()
                owner->pSignals = (TAHBSignals*) ctrl;
                ret = MX_STATUS_OK;
        }

    // TODO: Add your code here.

	return ret;
}

MxStatus 
ahb_s_TS::writeReq(MxU64 addr, MxU32* value, MxU32* ctrl, MxTransactionCallbackIF* callback)
{
	UNUSEDARG(addr);
	UNUSEDARG(value);
	UNUSEDARG(ctrl);
	UNUSEDARG(callback);
    // TODO: Add your code here.

	return MX_STATUS_NOTSUPPORTED;
}

MxGrant
ahb_s_TS::requestAccess(MxU64 addr)
{
	UNUSEDARG(addr);
    // TODO: Add your code here.

	return MX_GRANT_NOTSUPPORTED;
}

MxGrant
ahb_s_TS::checkForGrant(MxU64 addr)
{
	UNUSEDARG(addr);
    // TODO: Add your code here.

	return MX_GRANT_NOTSUPPORTED;
}

