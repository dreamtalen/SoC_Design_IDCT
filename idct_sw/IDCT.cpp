/*
 *    Class implementation of the SoC Designer component <IDCT>
 *
 *    This code has been generated by the SoC Designer Component Wizard.
 *    Copyright (c) 2004-2005 by ARM Limited, 2000-2004 by AXYS Design Automation Inc., Irvine, CA, USA and AXYS GmbH, Herzongenrath
 *
 */

#include "IDCT.h"

#include <stdio.h>


#include "ahb_TS.h"

#include "IDCT_MxDI.h"

static int index=0;

IDCT::IDCT(sc_mx_m_base* c, const string &s) : sc_mx_module(c, s)
{
    initComplete = false;

    ahb_TSlave = new ahb_TS( this );
    registerPort( ahb_TSlave, "ahb" );

    // Clocking the components
    SC_MX_CLOCKED();
    // Register ourself as a clock slave port.
    registerPort( dynamic_cast< sc_mx_clock_slave_p_base* >( this ), "clk-in");


    mxdi = NULL; 

    // Place parameter definitions here:
    defineParameter( "Enable Debug Messages", "false", MX_PARAM_BOOL);
    defineParameter( "ahb_addrSize", "0x100000000", MX_PARAM_VALUE, 0);
    defineParameter( "ahb_baseAddress", "0x0", MX_PARAM_VALUE, 0);

}

IDCT::~IDCT()
{

    delete ahb_TSlave;

}

void
IDCT::execute()
{

	//================================//
	//=== BEGIN: from original IDCT ===//
	//================================//
	int           m,n,x,y;

	short IDCT_coefficient[64]= 
		/*{ 181, 181, 181, 181, 181, 181, 181, 181,
	  251, 213, 142, 50 ,-50 ,-142,-213,-251,
	  237, 98 ,-98 ,-237,-237,-98 , 98 , 237,
	  213,-50 ,-251,-142, 142, 251, 50 ,-213,
	  181,-181,-181, 181, 181,-181,-181, 181,
	  142,-251, 50 , 213,-213,-50 , 251,-142,
	  98 ,-237, 237,-98 ,-98 , 237,-237, 98 ,
	  50 ,-142, 213,-251, 251,-213, 142,-50  };*/
	{ 64, 64, 64, 64, 64, 64, 64, 64,
	  89, 75, 50, 18 ,-18 ,-50,-75,-89,
	  83, 36 ,-36 ,-83,-83,-36 , 36 , 83,
	  75,-18 ,-89,-50, 50, 89, 18 ,-75,
	  64,-64,-64, 64, 64,-64,-64, 64,
	  50,-89, 18 , 75,-75,-18 , 89,-50,
	  36 ,-83, 83,-36 ,-36 , 83,-83, 36 ,
	  18 ,-50, 75,-89, 89,-75, 50,-18  };
	//================================//
	//=== END: from original IDCT   ===//
	//================================//			  
			      	
	switch( r_ctrl )
	{
		case 1:			// execute read
			Block[index] = (short) r_before;   // cloumn data in at first 
			index++;
			break;

		case 2:			// execute computation

			index = 0;
			
			//================================//
			//=== BEGIN: from original IDCT ===//
			//================================//


			for(y=0;y<2;y++)      //IDCT_1D*2
			{
				for(x=0;x<8;x++)  //IDCT_1D
				{
					if(y==0)      //column
					{
						x_t[0]=int(Block[   x]); 
						x_t[1]=int(Block[8 +x]);
						x_t[2]=int(Block[16+x]);
						x_t[3]=int(Block[24+x]);
						x_t[4]=int(Block[32+x]);
						x_t[5]=int(Block[40+x]);
						x_t[6]=int(Block[48+x]);
						x_t[7]=int(Block[56+x]);
						//message( MX_MSG_WARNING, "%d", x_t[0] );
					}
					else          //row
					{
						x_t[0]=int(Block[8*x  ]);
						x_t[1]=int(Block[8*x+1]);
						x_t[2]=int(Block[8*x+2]);
						x_t[3]=int(Block[8*x+3]);
						x_t[4]=int(Block[8*x+4]);
						x_t[5]=int(Block[8*x+5]);
						x_t[6]=int(Block[8*x+6]);
						x_t[7]=int(Block[8*x+7]);
					}

					for(m=0;m<8;m++)
					{
						y_t[m]=0;
						for(n=0;n<8;n++)
						{
							y_t[m]=y_t[m]+int(IDCT_coefficient[n*8+m])*x_t[n];
							//message( MX_MSG_WARNING, "%d", y_t[m] );
							//y_t[m]=n;
						}
					}

					if(y==0)
					{
						Block[   x]=short((y_t[0]+64)>>7);
						Block[8 +x]=short((y_t[1]+64)>>7);
						Block[16+x]=short((y_t[2]+64)>>7);
						Block[24+x]=short((y_t[3]+64)>>7);
						Block[32+x]=short((y_t[4]+64)>>7);
						Block[40+x]=short((y_t[5]+64)>>7);
						Block[48+x]=short((y_t[6]+64)>>7);
						Block[56+x]=short((y_t[7]+64)>>7);
						//message( MX_MSG_WARNING, "%d", Block[x] );
					}
					else
					{
						Block[8*x  ]=short((y_t[0]+2048)>>12);
						Block[8*x+1]=short((y_t[1]+2048)>>12);
						Block[8*x+2]=short((y_t[2]+2048)>>12);
						Block[8*x+3]=short((y_t[3]+2048)>>12);
						Block[8*x+4]=short((y_t[4]+2048)>>12);
						Block[8*x+5]=short((y_t[5]+2048)>>12);
						Block[8*x+6]=short((y_t[6]+2048)>>12);
						Block[8*x+7]=short((y_t[7]+2048)>>12);
					}
				} //End IDCT_1D	                  
			} //End IDCT_2D

			
			//================================//
			//=== END: from original IDCT   ===//
			//================================//
			
	
			break;

		case 3:

			r_after = Block[index];
			//message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%d> at runtime. Assignment ignored.", Block[index] );
			index++;
							
			break;

		case 4:
			index=0;
			break;

		default:
			break;		
	}

}

void
IDCT::communicate()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing communicate function");
	}
#endif

	// TODO:  Add your communicate code here.
	// ...
}

void
IDCT::update()
{
	// the following message will be printed only in the debug version of MxExplorer
#ifdef _DEBUG_
	if (p_enableDbgMsg == true)
	{
		message(MX_MSG_DEBUG,"Executing update function");
	}
#endif

	 // TODO:  Add your update code here.
	 // ...
}

void 
IDCT::init()
{

   // Create MXDI Interface
    mxdi = new IDCT_MxDI(this);
    r_ctrl = 0;
    r_before = 0;
    r_after = 0;

	
    // Initialize ourself for save/restore.
    //initStream( this );


    // Allocate memory and initialize data here:
    // ...
  
    // Call the base class after this has been initialized.
    sc_mx_module::init();

    // Set a flag that init stage has been completed
    initComplete = true;
}

void
IDCT::reset(MxResetLevel level, const MxFileMapIF *filelist)
{
    // Add your reset behavior here:
    // ...



    // Call the base class after this has been reset.
    sc_mx_module::reset(level, filelist);
}

void 
IDCT::terminate()
{
    // Call the base class first.
    sc_mx_module::terminate();

    // Release the MXDI Interface
    if(mxdi!=NULL) {delete mxdi; mxdi=NULL;}

    // Free memory which has been allocated in init stage
    // ...
}

void
IDCT::setParameter( const string &name, const string &value )
{
    MxConvertErrorCodes status = MxConvert_SUCCESS;

    if (name == "Enable Debug Messages")
    {
        status = MxConvertStringToValue( value, &p_enableDbgMsg  );
    }
    else if (name == "ahb_addrSize")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_addrSize );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }
    else if (name == "ahb_baseAddress")
    {
        if ( initComplete == false )
        {
            status = MxConvertStringToValue( value, &p_ahb_baseAddress );
        }
        else
        {
            message( MX_MSG_WARNING, "IDCT::setParameter: Cannot change parameter <%s> at runtime. Assignment ignored.", name.c_str() );
            return;
        }
    }

    if ( status == MxConvert_SUCCESS )
    {
        sc_mx_module::setParameter(name, value);
    }
    else
    {
        message( MX_MSG_WARNING, "IDCT::setParameter: Illegal value <%s> "
		 "passed for parameter <%s>. Assignment ignored.", value.c_str(), name.c_str() );
    }
}

string
IDCT::getProperty( MxPropertyType property )
{
    string description; 
    switch ( property ) 
    {    
	 case MX_PROP_LOADFILE_EXTENSION:
		return "";
	 case MX_PROP_REPORT_FILE_EXT:
		return "yes";
	 case MX_PROP_COMPONENT_TYPE:
		return "Other"; 
	 case MX_PROP_COMPONENT_VERSION:
		return "0.1";
	 case MX_PROP_MSG_PREPEND_NAME:
		return "yes"; 
	 case MX_PROP_DESCRIPTION:
		description = "";
		return description + " Compiled on " + __DATE__ + ", " + __TIME__; 
	 case MX_PROP_MXDI_SUPPORT:
		return "yes";
	 case MX_PROP_SAVE_RESTORE:
		return "yes";
	 default:
		return "";
    }
}

string
IDCT::getName(void)
{
    return "IDCT";
}

MXDI*
IDCT::getMxDI()
{
    return mxdi;
}


bool
IDCT::saveData( MxODataStream &data )
{
    data << r_ctrl;
    data << r_before;
    data << r_after;


    // TODO: Add your save code here.
    // Below line shows how the example state variable is saved. 
    // data << exampleStateVariable;


    // return save was successful
	return true;
}

bool
IDCT::restoreData( MxIDataStream &data )
{
    data >> r_ctrl;
    data >> r_before;
    data >> r_after;


    // TODO: Add your restore code here.
    // Below line shows how the example state variable is saved. 
    // data >> exampleStateVariable;


    // return restore was successful
	return true;
}

void
IDCT::initSignalPort(sc_mx_signal_p_base* signalIf)
{
    MxSignalProperties prop_sm1;
    memset(&prop_sm1,0,sizeof(prop_sm1));
    prop_sm1.isOptional=false;
    prop_sm1.bitwidth=32;
    signalIf->setProperties(&prop_sm1);
}

// This initTransactionPort() is only called for Transaction Master Ports.
// Do not call this function for any port which has its own initialization code.
void
IDCT::initTransactionPort(sc_mx_transaction_p_base* transIf)
{
    MxTransactionProperties prop;
    memset(&prop,0,sizeof(prop));
    prop.mxsiVersion = MXSI_VERSION_6;     //the transaction version used for this transaction
    prop.useMultiCycleInterface = false;    // using read/write interface methods
    prop.addressBitwidth = 32;      // address bitwidth used for addressing of resources 
    prop.mauBitwidth = 8;           // minimal addressable unit 
    prop.dataBitwidth = 32;         // maximum data bitwidth transferred in a single cycle 
    prop.isLittleEndian = true;     // alignment of MAUs 
    prop.isOptional = false;				// if true this port can be disabled 
    prop.supportsAddressRegions = true;	// M/S can negotiate address mapping
    prop.numCtrlFields = 1;         // # of ctrl elements used / entry is used for transfer size
    prop.protocolID = 0x00000001;           // magic number of the protocol (Vendor/Protocol-ID): 
				                             //The upper 16 bits = protocol implementation version
											//The lower 16 bits = actual protocol ID
    sprintf(prop.protocolName,"Mx");         // The name of the  protocol being used
    // MxSI 6.0: slave port address regions forwarding 
    prop.isAddrRegionForwarded = false; //true if addr region for this slave port is actually 
											//forwarded to a master port, false otherwise
    prop.forwardAddrRegionToMasterPort = NULL; //master port of the  same component to which this slave port's addr region is forwarded
    transIf->setProperties(&prop);
}

/************************
 * IDCT Factory class
 ***********************/

class IDCTFactory : public MxFactory
{
public:
    IDCTFactory() : MxFactory ( "IDCT" ) {}
    sc_mx_m_base *createInstance(sc_mx_m_base *c, const string &id)
    { 
        return new IDCT(c, id); 
    }
};

/**
 *  Entry point into the memory components (from SoC Designer)
 */
extern "C" void 
MxInit(void)
{
    new IDCTFactory();
}
